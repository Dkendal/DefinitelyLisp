import { A, B, I, M, Union } from :ts-toolbelt

import { __ } from :.

import {
  __capture__,
  __kind__,
  any_,
  bigint_,
  boolean_,
  function_,
  number_,
  object_,
  rest_,
  string_,
  symbol_,
} from :./const

type True as 1

type ExtractSubcapture(T) as
  match T do
    M::Primitive | M::BuiltIn => never,
    object => T[ Exclude(keyof(T), keyof([]) | keyof({})) ],
  end

type PartialAssignment(K, V) as
  match V do
    never => never,
    string =>
        map k in K do
            v
        end,
  end

type EmptyToNever(T) as
  if not ({} <: T) then
    T
  end

type Kind as
  :string
  | :number
  | :bigint
  | :boolean
  | :symbol
  | :object
  | :function
  | :any
  | :rest

export interface Hole(Type, Label)
defaults
  Type = any,
  Label = any
{
  T: Type,
  readonly [__kind__]: Label
}

export type HoleInnerType(T) as
  if T <: Hole(?U) then
    U
  else
    T
  end

export interface Capture(Name, Pattern)
defaults
  Name = any,
  Pattern = any,
where
  Name <: string,
  Pattern <: any,
{
  readonly [__capture__]: Name,
  readonly pattern: Pattern,
}

type CapturePattern(T) as
  if T <: Capture(any, ?Pattern) then
    Pattern
  else
    T
  end

type RecursiveExpandCapture(T) as
  if A::Equals(T, any) <: True then
    T
  else
    if T <: Hole | Capture then
      ExpandCapture(T)
    else
      if T <: Record(string, any) then
        map K in keyof(T) do
          ExpandCapture(T[K])
        end
      else
        never
      end
    end
  end

type RecursiveExpandCapture(T) as
  cond do
    A::Equals(T, any) <: True => T,
    T <: Hole | Capture => ExpandCapture(T),
    T <: Record(string, any) =>
        map K in keyof(T) do
          ExpandCapture(T[K])
        end
  end

export type ExpandCapture(T) as
  T
  |> HoleInnerType()
  |> CapturePattern()
  |> RecursiveExpandCapture()
