program = { SOI ~ NEWLINE* ~ statement* ~ NEWLINE* ~ EOI }

statement = { type_alias }

type_alias = {
    (#export = export)? ~ "type" ~ #name = ident ~ ("(" ~ #parameters = type_parameters ~ ")")? ~ #defaults = defaults_caluse? ~ #where = where_clause? ~ "as" ~ #body = expr
}

defaults_caluse = {
    "defaults" ~ #default = type_parameter_default ~ ("," ~ #default = type_parameter_default)* ~ ","?
}

where_clause = {
    "where" ~ #constraint = type_constraint ~ ("," ~ #constraint = type_constraint)* ~ ","?
}

type_parameter_default = {
    #name = ident ~ "=" ~ #value = expr
}

type_constraint = {
    #constraint_name = ident ~ extends ~ #constraint_body = expr
}

type_parameters = { ident ~ ("," ~ ident)* }

expr = { expr1 ~ (infix ~ expr1)* }

expr1 = _{ prefix* ~ primary ~ postfix* }

primary = _{
    if_expr
  | for_expr
  | match_expr
  | cond_expr
  | let_expr
  | builtin
  | application
  | term
  | "(" ~ expr ~ ")"
}

prefix = _{ infer }

infix = _{ union | intersection | pipe }

postfix = _{ indexed_access | dot_access | array_modifier }

array_modifier = @{ "[]" }

indexed_access = { "[" ~ expr ~ "]" }

dot_access = { "." ~ ident }

builtin = { #name = builtin_keyword ~ "(" ~ #argument = expr ~ ")" }

builtin_keyword = _{ keyof }

keyof = @{ "keyof" }

application = { ident ~ "(" ~ #arguments = argument_list ~ ")" }

argument_list = { expr ~ ("," ~ expr)* }

infer = @{ "?" }

neg = _{ "-" }

pipe = @{ "|>" }

union = @{ !pipe ~ "|" }

intersection = @{ "&" }

term = _{
    top_type
  | bottom_type
  | number
  | undefined
  | primitive
  | null
  | literal_true
  | literal_false
  | template_string
  | string
  | ident
  | tuple
  | object_literal
}

tuple = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }

top_type = _{ any | unknown }

bottom_type = _{ never }

primitive = {
    type_string
  | type_boolean
  | type_number
}

object_literal = {
    "{" ~ ((object_property ~ ",")* ~ object_property ~ ","?)? ~ "}"
}

object_property = {
    (#readonly = readonly_modifier)? ~ #key = ident ~ (#optional = optional_modifier)? ~ ":" ~ #value = expr
}

let_expr = {
    "let" ~ #binding = let_binding ~ ("," ~ #binding = let_binding)* ~ ","? ~ "in" ~ #body = expr
}

let_binding = {
    ident ~ "=" ~ expr
}

for_expr = {
    "for" ~ #index = ident ~ "in" ~ #iterable = expr ~ "do" ~ #body = expr ~ "end"
}

if_expr = {
    "if" ~ #condition = extends_condition ~ "then" ~ #then = expr ~ ("else" ~ #else = expr)? ~ "end"
}

match_expr = {
    "match" ~ #value = expr ~ "do" ~ #arm = match_arm ~ ("," ~ #arm = match_arm)* ~ ("," ~ #else = else_arm)? ~ ","? ~ "end"
}

match_arm = {
    #pattern = expr ~ "=>" ~ #body = expr
}

cond_expr = {
    "cond" ~ "do" ~ #arm = cond_arm ~ ("," ~ #arm = cond_arm)* ~ ("," ~ #else = else_arm)? ~ ","? ~ "end"
}

cond_arm = {
    #condition = extends_condition ~ "=>" ~ #body = expr
}

else_arm = {
    "else" ~ "=>" ~ #body = expr
}

extends_condition = { extends_expr }

extends_expr = _{
    extends_prefix* ~ extends_primary ~ (extends_prefix* ~ extends_infix ~ extends_primary)*
}

extends_primary = _{
    expr
  | "(" ~ extends_expr ~ ")"
}

extends_prefix = _{ not }

extends_infix = _{
    extends
  | not_extends
  | equals
  | strict_equals
  | strict_not_equals
  | and
  | or
}

extends = @{ "<:" }

not_extends = @{ "!<:" }

equals = @{ "=" }

not_equals = @{ "!=" }

strict_equals = @{ "==" }

strict_not_equals = @{ "!==" }

and = @{ "and" }

or = @{ "or" }

not = @{ "not" }

any = @{ "any" }

unknown = @{ "unknown" }

never = @{ "never" }

type_string = @{ "string" }

type_boolean = @{ "boolean" }

type_number = @{ "number" }

undefined = @{ "undefined" }

null = @{ "null" }

literal_true = @{ "true" }

literal_false = @{ "false" }

readonly_modifier = @{ "readonly" }

export = @{ "export" }

optional_modifier = @{ "?" }

string = { atom_string | double_quote_string | single_quote_string }

atom_string = @{ ":" ~ (!ASCII_DIGIT ~ (ASCII_ALPHANUMERIC | "$" | "_" | "-"))+ }

double_quote_string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

single_quote_string = @{ "'" ~ (!"'" ~ ANY)* ~ "'" }

template_string = @{ "`" ~ (!"`" ~ ANY)* ~ "`" }

ident = @{ !keyword ~ !ASCII_DIGIT ~ (ASCII_ALPHANUMERIC | "$" | "_")+ }

keyword = _{
    "as"
  | "any"
  | "boolean"
  | "class"
  | "const"
  | "else"
  | "end"
  | "extends"
  | "false"
  | "for"
  | "function"
  | "if"
  | "in"
  | "infer"
  | "interface"
  | "keyof"
  | "let"
  | "never"
  | "null"
  | "number"
  | "string"
  | "symbol"
  | "then"
  | "true"
  | "type"
  | "typeof"
  | "undefined"
  | "unknown"
  | "void"
}

number = @{
    (neg ~ WHITESPACE*)? ~ !"_" ~ (ASCII_DIGIT | "_")+ ~ ("." ~ !"_" ~ (ASCII_DIGIT | "_")*)?
}

COMMENT       = _{ BLOCK_COMMENT | LINE_COMMENT }
BLOCK_COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
LINE_COMMENT  = _{ "//" ~ (!NEWLINE ~ ANY)* }

WHITESPACE = _{ " " | "\t" | "\n" }
