program = { SOI ~ NEWLINE* ~ statement* ~ NEWLINE* ~ EOI }

statement = {
    type_alias
  | interface
  | import_statement
  | unittest
}

import_statement = {
    "import" ~ import_clause ~ from_clause
}

from_clause = _{
    "from" ~ string
}

import_clause = _{
    named_import
  | namespace_import
}

namespace_import = {
    "*" ~ "as" ~ #alias = ident
}

unittest = {
    "unittest" ~ #name = string ~ "do" ~ #body = (expr)* ~ "end"
}

named_import = {
    "{" ~ (#import_specifier = import_specifier ~ ("," ~ #import_specifier = import_specifier)*)? ~ ","? ~ "}"
}

import_specifier = {
    #name = ident ~ ("as" ~ #alias = ident)?
}

type_alias = {
    (#export = export)? ~ "type" ~ 
    #name = ident ~
    definition_options ~
    "as" ~ #body = expr
}

interface = {
    (#export = export)? ~ "interface" ~
    #name = ident ~
    definition_options ~
    #extends = extends_clause? ~
    #body = object_literal
}


definition_options = _{
    ("(" ~ #parameters = type_parameters ~ ")")? ~
    #defaults = defaults_caluse? ~
    #where = where_clause?
}

extends_clause = {
    "extends" ~ #name = ident
}

defaults_caluse = {
    "defaults" ~ #default = type_parameter_default ~ ("," ~ #default = type_parameter_default)* ~ ","?
}

where_clause = {
    "where" ~ #constraint = type_constraint ~ ("," ~ #constraint = type_constraint)* ~ ","?
}

type_parameter_default = {
    #name = ident ~ "=" ~ #value = expr
}

type_constraint = {
    #constraint_name = ident ~ extends ~ #constraint_body = expr
}

type_parameters = { ident ~ ("," ~ ident)* }

expr = { expr1 ~ (infix ~ expr1)* }

expr1 = _{ prefix* ~ primary ~ postfix* }

primary = _{
    if_expr
  | for_expr
  | match_expr
  | cond_expr
  | let_expr
  | builtin
  | application
  | term
  | "(" ~ expr ~ ")"
}

prefix = _{ infer }

infix = _{ union | intersection | pipe }

postfix = _{ namespace_access | indexed_access | dot_access | array_modifier }

namespace_access = { "::" ~ ident }

array_modifier = @{ "[]" }

indexed_access = { "[" ~ expr ~ "]" }

dot_access = { "." ~ ident }

builtin = { #name = builtin_keyword ~ "(" ~ #argument = expr ~ ")" }

builtin_keyword = _{ keyof | builtin_typeof }

keyof = @{ "keyof" }

builtin_typeof = @{ "typeof" }

application = { ident ~ "(" ~ #arguments = argument_list ~ ")" }

macro_call = { macro_ident ~ "(" ~ #arguments = argument_list ~ ")" }

argument_list = { expr ~ ("," ~ expr)* }

infer = @{ "?" }

neg = _{ "-" }

pipe = @{ "|>" }

union = @{ !pipe ~ "|" }

intersection = @{ "&" }

term = _{
    top_type
  | bottom_type
  | number
  | undefined
  | primitive
  | null
  | literal_true
  | literal_false
  | template_string
  | string
  | ident
  | tuple
  | object_literal
}

tuple = { "[" ~ (expr ~ ("," ~ expr)*)? ~ "]" }

top_type = _{ any | unknown }

bottom_type = _{ never }

primitive = {
    type_string
  | type_boolean
  | type_number
}

object_literal = {
    "{" ~ (object_property ~ ("," ~ object_property)* ~ ","?)? ~ "}"
}

object_property = {
    property_key ~ ":" ~ #value = expr
}

property_key = {
    property_key_prefix ~ #key = property_key_inner
}

property_key_prefix = _{
    (#readonly = readonly_modifier)? ~ (#optional = optional_modifier)?
}

property_key_inner = _{
    ident
  | ("[" ~ (index_property_key | computed_property_key) ~ "]")
}

computed_property_key = { ident }

index_property_key = {
    #index = ident ~ "in" ~ #iterable = expr ~ ("as" ~ #remap_clause = expr)?
}

let_expr = {
    "let" ~ #binding = let_binding ~ ("," ~ #binding = let_binding)* ~ ","? ~ "in" ~ #body = expr
}

let_binding = {
    ident ~ "=" ~ expr
}

for_expr = {
    "for" ~ property_key_prefix ~ index_property_key ~ "do" ~ #body = expr ~ "end"
}

if_expr = {
    "if" ~ #condition = extends_expr ~ "then" ~ #then = expr ~ (else_keyword ~ #else = expr)? ~ "end"
}

match_expr = {
    "match" ~ #value = expr ~ "do" ~ #arm = match_arm ~ ("," ~ #arm = match_arm)* ~ ("," ~ #else = else_arm)? ~ ","? ~ "end"
}

match_arm = {
    #pattern = expr ~ "=>" ~ #body = expr
}

cond_expr = {
    "cond" ~ "do" ~ #arm = cond_arm ~ ("," ~ #arm = cond_arm)* ~ ("," ~ #else = else_arm)? ~ ","? ~ "end"
}

cond_arm = {
    #condition = extends_expr ~ "=>" ~ #body = expr
}

else_arm = {
    else_keyword ~ "=>" ~ #body = expr
}

extends_expr = {
    extends_prefix* ~ extends_primary ~ (extends_prefix* ~ extends_infix ~ extends_primary)*
}

extends_primary = _{
    expr
  | "(" ~ extends_expr ~ ")"
}

extends_prefix = _{ not }

extends_infix = _{
    extends
  | not_extends
  | equals
  | not_equals
  | strict_equals
  | strict_not_equals
  | and
  | or
}

extends = @{ "<:" }

not_extends = @{ "</:" }

equals = @{ "=" }

not_equals = @{ "!=" }

strict_equals = @{ "==" }

strict_not_equals = @{ "!==" }

and = @{ "and" }

or = @{ "or" }

not = @{ "not" }

any = @{ "any" }

unknown = @{ "unknown" }

never = @{ "never" }

type_string = @{ "string" }

type_boolean = @{ "boolean" }

type_number = @{ "number" }

undefined = @{ "undefined" }

null = @{ "null" }

literal_true = @{ "true" }

literal_false = @{ "false" }

readonly_modifier = @{ "readonly" }

export = @{ "export" }

optional_modifier = @{ "?" }

else_keyword = @{ "else" }

string = { atom_string | double_quote_string | single_quote_string }

atom_string = @{ ":" ~ (!ASCII_DIGIT ~ (ASCII_ALPHANUMERIC | "$" | "_" | "-" | "/" | "\\" | "."))+ }

double_quote_string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

single_quote_string = @{ "'" ~ (!"'" ~ ANY)* ~ "'" }

template_string = @{ "`" ~ (!"`" ~ ANY)* ~ "`" }

macro_ident = @{ ident ~ "!" }

ident = @{ !(ASCII_DIGIT | keyword ~ !ident_chars) ~ ident_chars+ }

ident_chars = @{ ASCII_ALPHANUMERIC | "$" | "_" }

keyword = _{
    "as"
  | "any"
  | "boolean"
  | "class"
  | "const"
  | "export"
  | "extends"
  | "false"
  | "for"
  | "function"
  | "if"
  | "import"
  | "in"
  | "infer"
  | "interface"
  | "keyof"
  | "let"
  | "optional"
  | "readonly"
  | "never"
  | "not"
  | "null"
  | "number"
  | "string"
  | "symbol"
  | "then"
  | "true"
  | "type"
  | "typeof"
  | "undefined"
  | "unknown"
  | "void"
  | "unittest"
  | else_keyword
  | "end"
}

number = @{
    (neg ~ WHITESPACE*)? ~ !"_" ~ (ASCII_DIGIT | "_")+ ~ ("." ~ !"_" ~ (ASCII_DIGIT | "_")*)?
}

COMMENT       = _{ BLOCK_COMMENT | LINE_COMMENT }
BLOCK_COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
LINE_COMMENT  = _{ "//" ~ (!NEWLINE ~ ANY)* }

WHITESPACE = _{ " " | "\t" | "\n" }
